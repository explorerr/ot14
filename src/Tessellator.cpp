#include "Tessellator.h"

#define WIN32_LEAN_AND_MEAN
#define WIN32_EXTRALEAN
#include <windows.h>
#include <gl/glu.h>

#include <iostream>

// Declare GLUtesselator as an empty class to get rid of the linker warning (LNK4248)
class GLUtesselator {};



using namespace std;


Tessellator::Tessellator(void)
{
}


Tessellator::~Tessellator(void)
{
}


struct Point3D {
		
	/// <summary>Initializes a new Point3D</summary>
	/// <param name="xx">x coordinate</param>
	/// <param name="yy">y coordinate</param>
	/// <param name="zz">z coordinate</param>
public: Point3D(double xx, double yy, double zz) : x(xx), y(yy), z(zz) {}

	/// <summary>x coordinate</summary>
	public: double x;
			/// <summary>y coordinate</summary>
	public: double y;
			/// <summary>z coordinate</summary>
	public: double z;
};
	

typedef std::vector< Point3D > Point3DVector;


/// <summary>Stores the vertex indices for a triangle</summary>


/// <summary>Vector of triangles</summary>
typedef std::vector<Triangle> TriangleVector;

/// <summary>Vector of pointers to vertex indices</summary>
typedef std::vector<int *> VertexIndices;

/// <summary>Internal structure used to construct a tessellated character</summary>
struct TessellationSet {

	/// <summary>Destroys a tessellation set</summary>
	public: ~TessellationSet() {
				for(
					VertexIndices::const_reverse_iterator vertexIndex = this->Indices.rbegin();
					vertexIndex != this->Indices.rend();
				    ++vertexIndex
					) {
						delete *vertexIndex;
				}
			}

			/// <summary>Initializes a new tessellation set</summary>
	public: TessellationSet() {}

			/// <summary>The polygon's vertices</summary>
	public: Point3DVector Vertices;

			/// <summary>The triangles generated by the tessellator</summary>
	public: TriangleVector Triangles;

			/// <summary>Pointers to the numbers 0, 1, 2 and so on (really!)</summary>
	public: VertexIndices Indices;

			/// <summary>First index for an intermediate vertex</summary>
			/// <remarks>
			///   Contains the center vertex index for a triangle fan and the index of
			///   the older trailing vertex for a triangle strip. Stores the index of
			///   the first vertex in a triangle list.
			/// </remarks>
	public: int IntermediateVertexIndex1;

			/// <summary>Second index for an intermediate vertex</summary>
			/// <remarks>
			///   Stores the trailing vertex for a triangle fan and the newer trailing
			///   vertex for a triangle strip. Stores the index of the second vertex
			///   in a vertex list.
			/// </remarks>
	public: int IntermediateVertexIndex2;

			/// <summary>Type of primitives that the tessellator is outputting</summary>
	public: GLenum Type;

}; // struct TessellationSet

// ------------------------------------------------------------------------------------------- //

namespace { // anonymous

	/// <summary>Starts a new primitive in the tessellation process</summary>
	/// <param name="type">Type of the primitives to be drawn</param>
	/// <param name="tessellationSetAddress">
	///   TessellationSet in which to begin constructing a new polygon.
	/// </param>
	GLvoid CALLBACK tessBegin(GLenum type, void *tessellationSetAddress) {
		TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);

		tessellationSet.Type = type;
		tessellationSet.IntermediateVertexIndex1 = -1;
		tessellationSet.IntermediateVertexIndex2 = -1;
	}

} // anonymous namespace

// ------------------------------------------------------------------------------------------- //

namespace { // anonymous

	/// <summary>Ends the current primitive in the tessellation process</summary>
	/// <param name="tessellationSetAddress">
	///   TessellationSet in which to end the polygon currently in construction.
	/// </param>
	GLvoid CALLBACK tessEnd(void *tessellationSetAddress) {
		TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);
	}

} // anonymous namespace

// ------------------------------------------------------------------------------------------- //

namespace { // anonymous
	/// <summary>Adds a vertex to the primitives currently being constructed</summary>
	/// <param name="vertexData">
	///   Vertex user data; contains the required indices to indentify the corresponding
	///   vertex in the character's stored contour.
	/// </param>
	/// <param name="tessellationSetAddress">
	///   TessellationSet to which the vertex will be added
	/// </param>
	GLvoid CALLBACK tessVertex(void *vertexData, void *tessellationSetAddress) {
		TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);
		
	//	cout<<"in tessVertex"<<endl;
		int vertexIndex = *static_cast<int *>(vertexData);
		
	//	cout<<"in tessVertex, current vtx="<<vertexIndex<<endl;

		switch(tessellationSet.Type) {

			// An ordinary list of triangles. Three indices describe a single triangle,
			// then another three complete indices are sent to describe the next triangle.
			case GL_TRIANGLES: {
				if(tessellationSet.IntermediateVertexIndex1 == -1) {
					tessellationSet.IntermediateVertexIndex1 = vertexIndex;
					tessellationSet.IntermediateVertexIndex2 = -1;
				} else if(tessellationSet.IntermediateVertexIndex2 == -1) {
					tessellationSet.IntermediateVertexIndex2 = vertexIndex;
				} else {
					tessellationSet.Triangles.push_back(
						Triangle(
						tessellationSet.IntermediateVertexIndex1,
						tessellationSet.IntermediateVertexIndex2,
						vertexIndex
						)
						);
		//			cout<<"found triangle  GL_TRIANGLES="<<tessellationSet.IntermediateVertexIndex1<<", "<<
		//				                     tessellationSet.IntermediateVertexIndex2<<", "<<vertexIndex<<endl;
					tessellationSet.IntermediateVertexIndex1 = -1;
				}

				break;
			}

			// A triangle strip which reuses the 2 lastmost vertex indices and only adds
			// one new vertex to produce another triangle. Due to the algorithm,
			// the triangles would alternate between clockwise vertices and
			// counter-clockwise vertices, which has to be worked around.
			case GL_TRIANGLE_STRIP: {
				if(tessellationSet.IntermediateVertexIndex1 == -1) {
					tessellationSet.IntermediateVertexIndex1 = vertexIndex;
				} else if(tessellationSet.IntermediateVertexIndex2 == -1) {
					tessellationSet.IntermediateVertexIndex2 = vertexIndex;
				} else {
					tessellationSet.Triangles.push_back(
						Triangle(
						tessellationSet.IntermediateVertexIndex1,
						tessellationSet.IntermediateVertexIndex2,
						vertexIndex
						)
						);
		//			cout<<"found triangle  GL_TRIANGLE_STRIP="<<tessellationSet.IntermediateVertexIndex1<<", "<<
		//				                     tessellationSet.IntermediateVertexIndex2<<", "<<vertexIndex<<endl;
					tessellationSet.IntermediateVertexIndex1 = tessellationSet.IntermediateVertexIndex2;
					tessellationSet.IntermediateVertexIndex2 = vertexIndex;
				}

				break;
			}

			// Triangle fan where the first vertex index given stays put and is used
			// to form a triangles between the first vertex, the lastmost vertex and
			// the current vertex being processed.
			case GL_TRIANGLE_FAN: {
				if(tessellationSet.IntermediateVertexIndex1 == -1) {
					tessellationSet.IntermediateVertexIndex1 = vertexIndex;
				} else if(tessellationSet.IntermediateVertexIndex2 == -1) {
					tessellationSet.IntermediateVertexIndex2 = vertexIndex;
				} else {
					tessellationSet.Triangles.push_back(
						Triangle(
						tessellationSet.IntermediateVertexIndex1,
						tessellationSet.IntermediateVertexIndex2,
						vertexIndex
						)
						);
		//			cout<<"found triangle  GL_TRIANGLE_FAN="<<tessellationSet.IntermediateVertexIndex1<<", "<<
		//				                     tessellationSet.IntermediateVertexIndex2<<", "<<vertexIndex<<endl;
					tessellationSet.IntermediateVertexIndex2 = vertexIndex;
				}

				break;
			}
		}
	}

} // anonymous namespace

// ------------------------------------------------------------------------------------------- //

namespace { // anonymous

	/// <summary>Creates a new supporting vertex for the tessellator</summary>
	/// <param name="coords">Coordinates at which to place the new vertex</param>
	/// <param name="vertexData">
	///   Vertex user data for up to 4 vertices that are being connected
	///   to this vertex; contains the indices required to identify the corresponding
	///   vertices in the character's vertex list.
	/// </param>
	/// <param name="weight">
	///   Weight of the up to 4 vertices inbetween which the new vertex is being
	///   created. The weight of unused vertices will be set to 0.
	/// </param>
	/// <param name="newVertexData">
	///   Out parameter by which the vertex user data chunk for the new vertex
	///   can be returned to the tessellator.
	/// </param>
	/// <param name="tessellationSetAddress">
	///   TessellationSet in which to create the new vertex.
	/// </param>
	GLvoid CALLBACK tessCombine(
		GLdouble coords[3], void *vertexData[4], GLfloat weight[4], void **newVertexData,
		void *tessellationSetAddress
		) {
			TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);

			tessellationSet.Indices.push_back(new int(tessellationSet.Vertices.size()));
			tessellationSet.Vertices.push_back( Point3D(coords[0], coords[1], coords[2]));
		//	cout<<"in tessCombine new point=("<<coords[0]<<","<<coords[1]<<","<<coords[2]<<")"<<endl;
	}

} // anonymous namespace

// ------------------------------------------------------------------------------------------- //

void Tessellator::Tessellate(std::vector<double> polyOut, std::vector<double> polyIn, 
							 std::vector<Triangle> & tris,
							 std::vector<double> &vertices) {
	
	TessellationSet tessellationSet;
	int numVOut = polyOut.size()/3;
	for (int i=0; i<numVOut; i++) {
		tessellationSet.Indices.push_back(new int(tessellationSet.Vertices.size()));
		tessellationSet.Vertices.push_back(Point3D(polyOut[i*3], polyOut[i*3+1], polyOut[i*3+2]));
	}
	int numVIn = polyIn.size()/3;
	for (int i=0; i<numVIn; i++) {
		tessellationSet.Indices.push_back(new int(tessellationSet.Vertices.size()));
		tessellationSet.Vertices.push_back(Point3D(polyIn[i*3], polyIn[i*3+1], polyIn[i*3+2]));
	}

	size_t originalVertexCount = tessellationSet.Vertices.size();

	// Set up a new OpenGL GLU tessellator to generate triangles for this character.
	GLUtesselator *tessellator = ::gluNewTess();
	try {
		::gluTessCallback(tessellator, GLU_TESS_BEGIN_DATA, (GLvoid (CALLBACK *)())tessBegin);
		::gluTessCallback(tessellator, GLU_TESS_END_DATA, (GLvoid (CALLBACK *)())tessEnd);
		::gluTessCallback(tessellator, GLU_TESS_VERTEX_DATA, (GLvoid (CALLBACK *)())tessVertex);
		::gluTessCallback(tessellator, GLU_TESS_COMBINE_DATA, (GLvoid (CALLBACK *)())tessCombine);

		// The character is announced to the tessellator as one polygon (though, technically,
		// it could be several disjoint polygon shapes, which however is ok with the
		// OpenGL GLU tessellator).
		::gluTessBeginPolygon(tessellator, &tessellationSet);

		
		::gluTessBeginContour(tessellator);

		for(int index = 0; index < numVOut; ++index ) {
			GLdouble coords[3] = {
				(tessellationSet.Vertices[index].x),
				(tessellationSet.Vertices[index].y),
				(tessellationSet.Vertices[index].z)
			};

			::gluTessVertex(tessellator, coords, tessellationSet.Indices[index]);
		}

		::gluTessEndContour(tessellator);

		if(numVIn>0){
			
			::gluTessBeginContour(tessellator);

			for(int index = numVOut; index < numVOut+numVIn; ++index ) {
				GLdouble coords[3] = {
					(tessellationSet.Vertices[index].x),
					(tessellationSet.Vertices[index].y),
					(tessellationSet.Vertices[index].z)
				};

				::gluTessVertex(tessellator, coords, tessellationSet.Indices[index]);
			}

		::gluTessEndContour(tessellator);
		}


		::gluTessEndPolygon(tessellator);
	}catch(...){return;}
	
	::gluDeleteTess(tessellator);
	

		for(
			TriangleVector::const_iterator triangle = tessellationSet.Triangles.begin();
			triangle != tessellationSet.Triangles.end();
			++triangle 
				) {
			tris.push_back( Triangle(
									triangle->FirstVertexIndex, 
									triangle->SecondVertexIndex, 
									triangle->ThirdVertexIndex));
		}

	//		cout<<"number of vtx="<<tessellationSet.Vertices.size()<<endl;

		for(
			Point3DVector::const_iterator vtx = tessellationSet.Vertices.begin();
			vtx != tessellationSet.Vertices.end();
			++vtx
				) {
			vertices.push_back( vtx->x);
			vertices.push_back( vtx->y);
			vertices.push_back( vtx->z);

		}



			
/*	FILE * file;
	file = fopen("tris_1", "w");
	for(
	std::vector<int*>::const_iterator idx = tessellationSet.Indices.begin();
	idx != tessellationSet.Indices.end();
	++idx
	) {
		fprintf(file, "%d,\t", idx );
	}
	fprintf(file, "\n");

	for(size_t index = 0; index < tessellationSet.Vertices.size(); ++index) {
			fprintf(file, "%f %f %f \n",
				 tessellationSet.Vertices[index].x, tessellationSet.Vertices[index].y, tessellationSet.Vertices[index].z);				
		}
	fclose(file);

	// Add any supporting vertices the tessellator has created for us
/*	for(size_t index = numVOut+numVIn; index < tessellationSet.Vertices.size(); ++index) {
		characterContent->Vertices->Add(
			Vector2(tessellationSet.Vertices[index].first, tessellationSet.Vertices[index].second)
			);
	}

	// Transfer the triangle indices generated by the tessellator into our
	// .NET structures so they can be understood by the remaining code.
	for(
		TriangleVector::const_iterator triangle = tessellationSet.Triangles.begin();
		triangle != tessellationSet.Triangles.end();
	++triangle
		) {
			characterContent->Faces->Add(
				VectorFontCharacterContent::Face(
				triangle->FirstVertexIndex, triangle->SecondVertexIndex, triangle->ThirdVertexIndex
				)
				);
	}*/
}


